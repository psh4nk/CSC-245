Script started on Sun 09 Apr 2017 04:39:49 PM EDT
]0;shankle_p@cobra:~/CSC245/Prog3[?1034h[shankle_p@cobra Prog3]$ cat -n zip.cpp
     1	#include <iostream>
     2	#include <fstream>
     3	#include <string>
     4	#include <cstdlib>
     5	#include "huffman.h"
     6	using namespace std;
     7	
     8	void CountLetters (int Letters[], string& s);
     9	void insertLetters (const int Letters[], HuffmanTree& tree);
    10	void openFile(HuffmanTree& tree, int& argc, char *argv[]);
    11	string writeout(string filename, HuffmanTree& tree, string& s);
    12	
    13	const int NumLetters = 256;
    14	
    15	int main(int argc, char *argv[])
    16	{
    17		HuffmanTree tree;
    18		openFile(tree, argc, argv);
    19		return 0;
    20	}
    21	
    22	void CountLetters (int Letters[], string& s)
    23	{
    24		// Pre	: Letters has been initialized, string s contains file contents
    25		// Post	: Number of total characters has been determined
    26	
    27		char ch;
    28	
    29		for (char ch = char(0);  ch <= char(126);  ch++)
    30	            Letters[ch] = 0;
    31	 	bool ran = false;	
    32	         for(int i = 0; i < s.length() + 1; i++)
    33	         {
    34		  	if(!ran)
    35			{
    36				ch = s[i];
    37				ran = true;
    38			}
    39			else
    40			{
    41			 Letters[ch] += 1;
    42			 ch = s[i];
    43			}
    44		 }
    45		 ch = '\n';
    46		 Letters[ch] += 1;
    47	}
    48	
    49	void insertLetters (const int Letters[], HuffmanTree& tree)
    50	{
    51	 	// Pre	: Tree has been initialized, Letters[] contains letter counts
    52		// Post	: All characters are inserted into the tree along with their weights from Letters[]
    53	
    54	  	for (char ch = char(0);  ch <= char(126);  ch++)
    55		{
    56		  if ( (Letters[ch] != 0) && (ch != '\n') && (ch != ' ') )      
    57			tree.insert(ch, Letters[ch]);	  
    58		  else if ( (Letters[ch] != 0) && (ch == '\n') )
    59		        tree.insert('\n',Letters[ch]); 
    60	       	  else if ( (Letters[ch] != 0) && (ch == ' ') )
    61		  	tree.insert(' ', Letters[ch]);
    62		}
    63	}
    64	
    65	void openFile(HuffmanTree& tree, int& argc, char *argv[])
    66	{
    67		// Pre	: Tree has been initialized but contains no data
    68		// Post	: Zip file is written out and program exits
    69	
    70		int Letters[NumLetters] = {};
    71		string filename, arg, s;	
    72		bool print = false;	
    73		if(argv[1])
    74			filename = argv[1];
    75		else
    76		{
    77			cerr << "ZIP: Invalid input\nTry 'ZIP --help' for more information.\n";
    78			exit(0);
    79		}
    80		ifstream infile;
    81		infile.open(filename.c_str());
    82		if(!infile.is_open())
    83		{
    84			if(filename == "--t")
    85				print = true;
    86			else if(filename == "--help"){
    87				string help;
    88				ifstream helpfile;
    89				helpfile.open("help");
    90				while(getline(helpfile, help))
    91					cout << help << endl;
    92				exit(0);
    93			}
    94			else
    95			{
    96				cerr << "ZIP: Invalid input\nCheck to see if file exists\nTry `ZIP --help' for more information.\n";
    97				exit(0);
    98			}
    99		}
   100		if(argv[2])
   101		{
   102			filename = argv[2];
   103			infile.open(filename.c_str());
   104			if(!infile.is_open()){
   105				cerr << "ZIP: File does not exist.\nTry 'ZIP --help' for more information.\n";
   106				exit(0);
   107			}
   108		}
   109	
   110		getline(infile, s);
   111		CountLetters(Letters, s);
   112		insertLetters(Letters, tree);
   113		tree.build();
   114		string result = writeout(filename, tree, s);
   115		if(print)
   116			tree.PrintTable();	
   117		cout << "\nFile Successfully Compressed To " << result.length()  << " Bits (" << (1 - (double)(((double)result.length())/((double)((double)tree.GetNumChars()*8))))*100 << "% Less)." << endl;
   118	}
   119	
   120	string writeout(string filename, HuffmanTree& tree, string& s)
   121	{
   122		// Pre	: Tree has been built, filename has been filled
   123		// Post	: Result is written out to file
   124		
   125		ofstream outfile;
   126		filename = filename + ".zip";
   127		outfile.open(filename.c_str());
   128		outfile << tree.GetNumChars() << endl;
   129	        for(int i = 0; i < tree.numNodes() ; i++)
   130	        {
   131	                if(tree.GetChar(i) != '\0')
   132	                        outfile << (int)tree.GetChar(i) << " " << tree.GetCode(tree.GetChar(i)) << endl;
   133	        }
   134		string result;
   135	        for (int i = 0; i < s.length(); i++)
   136	        {
   137	                string code = tree.GetCode(s[i]);
   138	                result += code;
   139	        }
   140	        outfile << result;
   141		return result;
   142	}
   143	
]0;shankle_p@cobra:~/CSC245/Prog3[shankle_p@cobra Prog3]$ cat huffman.h
#include <vector>
#include <string>
using namespace std;

struct HNode {
    char ch;
    int weight;
    int parent;
    int childType;
};

class HuffmanTree {
    public:
	HuffmanTree();				// constructor

	void insert(char ch, int weight);	// inserts a character and its associated weight
						// into a node of the Huffman tree

	bool inTree(char ch);			// returns a boolean value indicating whether
						// a given character is stored in the tree
		
	int GetFrequency(char ch);		// returns the weight of a given character

	
	char GetChar(int i);


	int GetNumChars();

	
	void build();				// Builds the Huffman Tree;


	int getSmaller(int compare);		// Compare two values in the Huffman Tree, return smaller 

	
	string GetCode(char ch);		// returns the compressed code of a given
						// character in the tree using recursion

	void PrintTable();			// displays the Huffman encoding table used in
						// the compression process
	
	int numNodes();				// returns the number of nodes currently in Huffman 
						// tree

    private:
	vector<HNode> nodes;
	int numChars;
	bool built;                             
	
	int lookUp(char ch);			// returns the index of a given character in tree
	int GetFrequency(int i);		// returns the weight at a given index
	string GetCode(int i);			// returns the compressed code of the character at 
						// a given index
};
]0;shankle_p@cobra:~/CSC245/Prog3[shankle_p@cobra Prog3]$ cat huffman.cpp
#include "huffman.h"
#include <iostream>
#include <queue>
using namespace std;

HuffmanTree:: HuffmanTree()
	: numChars(0), built(false) {}

void HuffmanTree:: insert(char ch, int weight) {
    HNode newNode = {ch, weight, -1, -1}; 
    built = false;
    nodes.push_back(newNode);
    numChars++;
}

bool HuffmanTree:: inTree(char ch) {
	return (lookUp(ch) != -1);
}

int HuffmanTree:: GetFrequency(char ch) {
	return GetFrequency(lookUp(ch));
}

int HuffmanTree:: GetFrequency(int i) {
	return nodes[i].weight;		
}

char HuffmanTree:: GetChar(int i){
	return nodes[i].ch;
}

int HuffmanTree:: GetNumChars(){
	return numChars;
}

int HuffmanTree:: lookUp(char ch) {
	int index = -1;
	for(int i = 0; i < nodes.size() - 1; i++)
	{
		if(nodes[i].ch == ch)
		{	
			index = i;
		}
	}
	return index;
}

string HuffmanTree:: GetCode(char ch) {
	return GetCode(lookUp(ch));	
}


string HuffmanTree:: GetCode(int i) {
 	 if (nodes[i].parent == 0)
           return "";
      	 else
            return (GetCode(nodes[i].parent) + (char)(nodes[i].childType+'0'));
}

void HuffmanTree:: PrintTable() {
	int tcounter = 1;
	cout << "\t\t++++ ENCODING TABLE ++++\t\n\n";
	cout << "\tIndex\tChar\tWeight\tParent\tChildType\n";
	for(int i = 0; i < numChars * 2 - 1; i++)
		if(nodes[i].ch != '\n' && nodes[i].ch != ' ' && nodes[i].ch)
			cout << '\t' << i << "\t" << nodes[i].ch << "\t" << nodes[i].weight << "\t" << nodes[i].parent << "\t" << nodes[i].childType << "\n";
		else if(nodes[i].ch == '\n')
			cout << '\t' << i << "\tnl\t" << nodes[i].weight << "\t" << nodes[i].parent << "\t" << nodes[i].childType << "\n";
		else if(nodes[i].ch == ' ')
			cout << '\t' << i << "\tsp\t" << nodes[i].weight << "\t" << nodes[i].parent << "\t" << nodes[i].childType << "\n";
		else if(i != numChars*2-2)
		{
			cout << '\t' << i << "\tT" << tcounter << "\t" << nodes[i].weight << "\t" << nodes[i].parent << "\t" << nodes[i].childType << "\n";
			tcounter++;
		}
		else
                       cout << '\t' << i << "\tT" << tcounter << "\t" << nodes[i].weight << "\t0\tN/A\n";

}

int HuffmanTree:: numNodes() {
	return numChars*2-1;

}

void HuffmanTree:: build() {
	for(int j = 0; j < numChars* 2 - 1; j++)
	{
		if(getSmaller(j) != -1 && ((nodes[j].parent == -1 || nodes[getSmaller(j)].parent == -1)))
		{
			HNode newNode = {'\0', nodes[j].weight + nodes[getSmaller(j)].weight, -1, -1};
			nodes.push_back(newNode);
			nodes[j].parent = nodes.size() - 1;
			nodes[getSmaller(j)].parent = nodes.size() - 1;
			j++;
			if(getSmaller(j) != -1)
   		        {
				nodes[j].parent = nodes.size() - 1;
				nodes[getSmaller(j)].parent = nodes.size() - 1;
			}
		}
	}
	for(int i = 0; i < nodes.size() - 1; i++)
	{
		nodes[i].childType = 0;
		i++;
		nodes[i].childType = 1;
	}
	nodes[nodes.size() - 1].parent = 0;
	nodes[nodes.size() - 1].childType = -1;
}

int HuffmanTree:: getSmaller(int compare){
	int result = -1;
	for(int i = 0; i < nodes.size() - 1; i++)
		if(nodes[i].weight <= nodes[compare].weight && i != compare)	
			result = i;
	return result;
}
]0;shankle_p@cobra:~/CSC245/Prog3[shankle_p@cobra Prog3]$ c++ huffman[K[K[K[K[K[K[Kzip.cpp huffman.o
]0;shankle_p@cobra:~/CSC245/Prog3[shankle_p@cobra Prog3]$ c++ zip.cpp huffman.o[1@-[1@o[1@ [1@Z[1P[1@m[1@y[C[1@z[1P[1@Z[1@I[1@P[1P[1P[1@i[1@p[1@ 
]0;shankle_p@cobra:~/CSC245/Prog3[shankle_p@cobra Prog3]$ c++ -o myUnzip unzip.cpp
]0;shankle_p@cobra:~/CSC245/Prog3[shankle_p@cobra Prog3]$ M[KmyZip --t sample4
		++++ ENCODING TABLE ++++	

	Index	Char	Weight	Parent	ChildType
	0	nl	1	11	0
	1	sp	1	11	1
	2	M	2	12	0
	3	a	2	12	1
	4	c	1	13	0
	5	d	1	13	1
	6	e	1	14	0
	7	h	1	14	1
	8	n	1	15	0
	9	r	1	15	1
	10	s	2	16	0
	11	T1	2	16	1
	12	T2	4	17	0
	13	T3	2	17	1
	14	T4	2	18	0
	15	T5	2	18	1
	16	T6	4	19	0
	17	T7	6	19	1
	18	T8	4	20	0
	19	T9	10	20	1
	20	T10	14	0	N/A

File Successfully Compressed To 46 Bits (47.7273% Less).
]0;shankle_p@cobra:~/CSC245/Prog3[shankle_p@cobra Prog3]$ myUnzip[K[K[K[K[K[K[Kcat sample4[K4.zip
11
10 1010
32 1011
77 1100
97 1101
99 1110
100 1111
101 000
104 001
110 010
114 011
115 100
1100110101111100011011110011011111010000100100]0;shankle_p@cobra:~/CSC245/Prog3[shankle_p@cobra Prog3]$ myUni[Kzip sample4.zip
File Successfully Inflated Back to Original
]0;shankle_p@cobra:~/CSC245/Prog3[shankle_p@cobra Prog3]$ cat sample4
March Madness]0;shankle_p@cobra:~/CSC245/Prog3[shankle_p@cobra Prog3]$ exit
exit

Script done on Sun 09 Apr 2017 04:42:04 PM EDT
